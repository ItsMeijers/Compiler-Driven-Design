# 1. Introduction

​	In functional programming, nirvana is a transcendent state in which there is neither suffering, mutability, nor sense of shortcuts, and the subject is released from all side effects and the cycle of the expression problem. But how does one functional programmer reach this nirvana? The expression problem is a new name for an old problem. The goal is to define a datatype by cases, where one can add new cases to the datatype and new functions over the datatype, without recompiling existing code, and while retraining static type safety (e.g., no casts). [1] This term was first presented by Philip Wadler, a computer scientist known for many contributions to programming language design, type theory and the Haskell language. As mortal functional programmers, we stand of the shoulders of giants such as Philip Wadler, these who are creating better programming languages and compilers so that we can create better applications. But what more can we learn from all the techniques used within the compiler construction field? This book introduces the concept of _Compiler Driven Design_ (CDD), an architectural style based on techniques used within compiler construction and research. The goal of CDD is creating software that is immutable, pure, highly composable and easy testable for verification and regression which will free us from the expression problem, in other words reach functional programming nirvana. 

​	What is a compiler? A *compiler* is a program that translates a source program written in some high-level programming language (such as Java) into machine code for some computer architecture (such as the Intel Pentium architecture). The generated code can be later executed many times against different data each time. -> An *interpreter* reads an executable source program written in a high-level programming language as well as data for this program, and it runs the program against the data to produce some results -> Technically speaking the book will introduce techniques taken from compiler construction, but will use this techniques to write interpreters for a domain specific language to create _"business"_ applications. 

​	Put the theory to the test by implementing the same application using different techniques. How is each technique explained: Concept explained, Simple examples, Application implementation, Testing, Performance Analysis, Difficulty, Extra resources.

​	What is covered, first Prerequisites, second the application and its domain, four Techniques: The first technique is the Free Monad with Coproducts. The second technique is tagless-final. The third technique is Recursion Schemes. The fourth technique is Continuation Passing Style (CPS).  Then Choosing and combining CDD techniques are covered. Finally a conclusion is drawn with future work.  Appendix A. contains the code examples in Scala.

​	[1] The Expression Problem By Philip Wadler - http://homepages.inf.ed.ac.uk/wadler/papers/expression/expression.txt